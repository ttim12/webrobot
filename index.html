<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js 进阶手势粒子系统</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        #ui-panel {
            position: absolute;
            top: 20px; right: 20px; width: 260px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            z-index: 10;
        }
        
        h2 { margin: 0 0 10px 0; font-size: 18px; }
        p { font-size: 12px; opacity: 0.7; margin-bottom: 15px; }

        /* 状态指示器 */
        #status-indicator {
            margin-top: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
            color: #00ffcc;
            font-weight: bold;
        }

        #video-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 10px; overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            z-index: 5; transform: scaleX(-1);
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        #loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 20px; z-index: 20;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loader">正在启动摄像头与AI模型...</div>

    <div id="ui-panel">
        <h2>✨ 粒子操控台 2.0</h2>
        <p>1. 比划数字 1, 2, 3 粒子变形<br>2. 左右挥手旋转视角<br>3. 双手开合控制大小</p>
        
        <label>粒子颜色</label>
        <input type="color" id="color-picker" value="#00ffff" style="width:100%; border:none; height:30px;">
        
        <div id="status-indicator">等待手势...</div>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

<script>
    // --- 1. Three.js 场景搭建 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 35;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 2. 粒子系统 ---
    const particleCount = 20000; // 增加粒子数以获得更好的形状细节
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    
    for(let i=0; i<particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 100;
        targetPositions[i] = positions[i];
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0x00ffff,
        size: 0.25,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. 形状生成算法 (新增数字 1, 2, 3) ---
    // 辅助函数：随机点在直线上
    function pointOnLine(x1, y1, x2, y2) {
        const t = Math.random();
        return {
            x: x1 + (x2 - x1) * t,
            y: y1 + (y2 - y1) * t,
            z: (Math.random() - 0.5) * 2 // 少量厚度
        };
    }
    
    // 辅助函数：随机点在圆弧上
    function pointOnArc(centerX, centerY, radius, startAngle, endAngle) {
        const angle = startAngle + Math.random() * (endAngle - startAngle);
        return {
            x: centerX + radius * Math.cos(angle),
            y: centerY + radius * Math.sin(angle),
            z: (Math.random() - 0.5) * 2
        };
    }

    const shapes = {
        sphere: () => {
            const r = 12 * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return { x: r*Math.sin(phi)*Math.cos(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(phi) };
        },
        // 数字 1
        num1: (i) => {
            const part = Math.random();
            if (part < 0.8) { 
                // 竖线 (x=0, y: -10 ~ 10)
                return pointOnLine(0, -10, 0, 10);
            } else {
                // 顶部撇 (x: -3 ~ 0, y: 7 ~ 10)
                return pointOnLine(-3, 7, 0, 10);
            }
        },
        // 数字 2
        num2: (i) => {
            const part = Math.random();
            if (part < 0.4) {
                // 顶部半圆 (圆心0, 5, 半径5)
                return pointOnArc(0, 5, 5, 0, Math.PI);
            } else if (part < 0.7) {
                // 斜线 (右上到左下)
                return pointOnLine(5, 5, -5, -10);
            } else {
                // 底部横线
                return pointOnLine(-5, -10, 5, -10);
            }
        },
        // 数字 3
        num3: (i) => {
            const part = Math.random();
            if (part < 0.5) {
                // 上半圆
                return pointOnArc(0, 5, 4, -Math.PI/2, Math.PI*1.2);
            } else {
                // 下半圆
                return pointOnArc(0, -5, 5, -Math.PI*1.2, Math.PI/2);
            }
        },
        heart: (i) => {
            const t = Math.random() * Math.PI * 2;
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            return { x: x * 0.8, y: y * 0.8, z: (Math.random()-0.5)*4 };
        }
    };

    let currentShape = 'sphere';

    function transformTo(shapeName) {
        if (currentShape === shapeName) return; // 避免重复计算
        currentShape = shapeName;
        
        const func = shapes[shapeName] || shapes.sphere;
        for(let i=0; i<particleCount; i++) {
            const pos = func(i);
            // 稍微放大一点数字，让它们更清楚
            const scale = (shapeName.startsWith('num')) ? 1.2 : 1.0;
            targetPositions[i*3] = pos.x * scale;
            targetPositions[i*3+1] = pos.y * scale;
            targetPositions[i*3+2] = pos.z * scale;
        }
    }

    // 初始形状
    transformTo('sphere');

    // --- 4. 手势交互逻辑 (旋转 & 变形) ---
    const statusDiv = document.getElementById('status-indicator');
    
    // 交互变量
    let handScale = 1.0; 
    let targetRotationX = 0;
    let targetRotationY = 0;
    let gestureDebounceTimer = null; // 防抖

    function countFingers(landmarks) {
        let count = 0;
        const tips = [8, 12, 16, 20]; 
        const pips = [6, 10, 14, 18];
        // 简单的手指伸直检测 (指尖高于关节)
        tips.forEach((tip, i) => { if (landmarks[tip].y < landmarks[pips[i]].y) count++; });
        
        // 拇指检测 (根据手掌方向判断x轴)
        // 简单处理：如果拇指尖的x比拇指关节更远离小指，就算伸出
        // 这是一个非常简化的判断，实战中可能需要更复杂的向量计算
        // 为了演示数字123，我们主要关注食指(8)、中指(12)、无名指(16)
        return count; 
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });

    hands.onResults((results) => {
        document.getElementById('loader').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // --- 需求 2: 手掌位置控制旋转 (反向偏转/跟随) ---
            // 获取手掌中心 (大概是索引 9 的位置)
            const palmX = landmarks[9].x; // 0 (左) -> 1 (右)
            const palmY = landmarks[9].y; // 0 (上) -> 1 (下)
            
            // 映射到旋转角度 (-1 到 1 之间 *系数)
            // 比如：手在右边(x>0.5)，粒子向右转(y轴旋转增加)
            // 你说"相对应的反正偏转"，这里我做了"跟随"效果，手往右，物体往右转看侧面
            const rotSpeed = 1.5;
            targetRotationY = (palmX - 0.5) * rotSpeed * Math.PI; 
            targetRotationX = (palmY - 0.5) * rotSpeed * Math.PI;

            // --- 需求 1 & 基础: 缩放与数字识别 ---
            let distance = 0;
            // 双手模式
            if (results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0][0];
                const hand2 = results.multiHandLandmarks[1][0];
                distance = Math.sqrt(Math.pow(hand1.x-hand2.x, 2) + Math.pow(hand1.y-hand2.y, 2)) * 3;
            } else {
                // 单手缩放 (拇指+食指)
                distance = Math.sqrt(Math.pow(landmarks[4].x-landmarks[8].x, 2) + Math.pow(landmarks[4].y-landmarks[8].y, 2)) * 5;
            }
            // 平滑缩放
            handScale += ((0.5 + distance) - handScale) * 0.1;

            // --- 数字手势触发 ---
            const fingerCount = countFingers(landmarks);
            
            // 简单的防抖逻辑，避免瞬间切换
            if (!gestureDebounceTimer) {
                if (fingerCount === 1) {
                    transformTo('num1');
                    statusDiv.innerText = "识别: 数字 1";
                } else if (fingerCount === 2) {
                    transformTo('num2');
                    statusDiv.innerText = "识别: 数字 2";
                } else if (fingerCount === 3) {
                    transformTo('num3');
                    statusDiv.innerText = "识别: 数字 3";
                } else if (fingerCount === 5 || fingerCount === 0) {
                    transformTo('sphere'); // 张开手或握拳恢复球体
                    statusDiv.innerText = "模式: 自由操控";
                }
                
                // 设置200ms的冷却时间，避免闪烁
                gestureDebounceTimer = setTimeout(() => { gestureDebounceTimer = null; }, 200);
            }

        } else {
            // 没检测到手，慢慢回正
            targetRotationX *= 0.95;
            targetRotationY *= 0.95;
            handScale += (1.0 - handScale) * 0.05;
            statusDiv.innerText = "未检测到手势";
        }
    });

    const cameraUtils = new Camera(document.getElementById('input-video'), {
        onFrame: async () => await hands.send({image: document.getElementById('input-video')}),
        width: 320, height: 240
    });
    cameraUtils.start();

    // --- 5. 动画循环 ---
    const clock = new THREE.Clock();
    
    // UI 颜色控制
    document.getElementById('color-picker').addEventListener('input', (e) => {
        material.color.set(e.target.value);
    });

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        const positionsArray = geometry.attributes.position.array;

        // --- 核心逻辑：应用旋转 ---
        // 使用 Lerp 平滑过渡到目标角度
        particles.rotation.y += (targetRotationY - particles.rotation.y) * 0.05;
        particles.rotation.x += (targetRotationX - particles.rotation.x) * 0.05;
        
        // 基础自转 (如果没有手势操控时保留一点微动)
        if (Math.abs(targetRotationY) < 0.1) {
            particles.rotation.y += 0.002; 
        }

        // 粒子更新
        for (let i = 0; i < particleCount; i++) {
            const idx = i * 3;
            const tx = targetPositions[idx];
            const ty = targetPositions[idx+1];
            const tz = targetPositions[idx+2];

            const cx = positionsArray[idx];
            const cy = positionsArray[idx+1];
            const cz = positionsArray[idx+2];

            // 1. 变形 Morphing
            positionsArray[idx]   += (tx - cx) * 0.08;
            positionsArray[idx+1] += (ty - cy) * 0.08;
            positionsArray[idx+2] += (tz - cz) * 0.08;

            // 2. 噪声干扰 (让粒子看起来是活的)
            const noise = Math.sin(time * 3 + cx * 0.1) * 0.05;
            positionsArray[idx] += noise;
            
            // 3. 应用手势缩放 (向中心缩放)
            // 注意：这里我们通过修改 geometry 实现缩放，和 rotation 分开
            // 最简单的方法是直接缩放整个 Object3D，但为了保持粒子特效的质感，
            // 我们这里通过视觉上的fov或者简单的缩放系数来做
        }
        
        // 简单暴力应用缩放
        particles.scale.set(handScale, handScale, handScale);

        geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }
    
    // 窗口自适应
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
