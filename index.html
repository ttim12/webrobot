<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 战术狙击系统 (全能版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- TensorFlow.js Core & Models -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        /* 视频层 */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* 更平滑的变焦 */
            display: none; /* 初始隐藏，JS加载完后会显示 */
        }

        /* 狙击镜模式下的视频放大 */
        video.zoomed {
            transform: scale(2.5); /* 2.5倍变焦 */
            transform-origin: center;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none; /* 确保点击事件穿透给下层，或者由JS统一处理 */
        }

        /* 狙击镜遮罩 - 纯CSS实现 */
        .scope-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.8) 35%, #000 60%);
            pointer-events: none;
            display: none;
        }
        
        .scope-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            z-index: 6; /* 在 Canvas 之上 */
            pointer-events: none;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .cross-line {
            background: rgba(255, 0, 0, 0.8);
            position: absolute;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
        }

        /* 射击按钮 */
        #fireBtn {
            position: absolute;
            bottom: 40px;
            right: 40px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(4px);
            transition: all 0.1s;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
            text-shadow: 0 0 5px #f00;
            cursor: pointer;
        }
        #fireBtn:active {
            background: rgba(255, 0, 0, 0.8);
            transform: scale(0.95);
        }

        /* 狙击模式切换按钮 */
        #scopeToggle {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #0f0;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #0f0;
            font-size: 24px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }
        #scopeToggle.active {
            background: rgba(0, 255, 0, 0.6);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }

        /* 受击反馈闪烁 */
        @keyframes hit-flash {
            0% { background: rgba(255,0,0,0); }
            10% { background: rgba(255,0,0,0.3); }
            100% { background: rgba(255,0,0,0); }
        }
        .hit-effect {
            animation: hit-flash 0.2s ease-out;
        }
    </style>
</head>
<body>

    <div id="container">
        <!-- 注意：video 移除了 display: none，通过 JS 控制显示 -->
        <video id="webcam" playsinline muted></video>
        <canvas id="output"></canvas>
        
        <!-- 狙击镜视觉层 -->
        <div id="scopeOverlay" class="scope-overlay"></div>
        <div id="scopeCrosshair" class="scope-crosshair">
            <!-- 十字准星 -->
            <div class="cross-line" style="width: 2px; height: 60px;"></div>
            <div class="cross-line" style="width: 60px; height: 2px;"></div>
            <div style="position:absolute; width: 300px; height: 300px; border: 1px solid rgba(255,0,0,0.4); border-radius: 50%;"></div>
            <div style="position:absolute; width: 4px; height: 4px; background: red; border-radius: 50%;"></div>
            <div class="text-red-500 text-xs font-mono absolute mt-20 animate-pulse">LOCKED ON</div>
        </div>

        <!-- 击杀计数 -->
        <div class="absolute top-6 right-6 z-30 font-mono text-right pointer-events-none drop-shadow-md">
            <div class="text-green-500 text-sm">NEUTRALIZED</div>
            <div id="killCount" class="text-red-500 text-4xl font-bold tracking-tighter">00</div>
        </div>

        <!-- 武器状态 -->
        <div class="absolute top-6 left-6 z-30 font-mono pointer-events-none drop-shadow-md">
            <div class="text-green-500 text-sm">SYSTEM STATUS</div>
            <div class="text-green-400 text-lg">SCANNING...</div>
            <div id="ammoDisplay" class="text-yellow-400 text-xs mt-1">MODE: HYBRID RECON</div>
        </div>

        <!-- 控制按钮 -->
        <button id="scopeToggle">
            <!-- Target Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></svg>
        </button>
        <button id="fireBtn">FIRE</button>
    </div>

    <!-- 加载层 -->
    <div id="loadingOverlay" class="absolute inset-0 bg-black z-50 flex flex-col items-center justify-center p-4">
        <h2 class="text-2xl font-bold text-green-500 mb-2 tracking-widest">TACTICAL OS V3.0</h2>
        <div class="w-64 bg-gray-900 h-2 rounded overflow-hidden mt-4">
            <div id="progressBar" class="h-full bg-green-600 w-0 transition-all duration-300"></div>
        </div>
        <p id="loadDetail" class="text-green-800 text-xs mt-2 font-mono">Initializing Neural Networks...</p>
        <button id="startBtn" disabled class="mt-8 px-8 py-3 border border-green-700 text-green-500 opacity-50 font-bold tracking-widest transition-all">WAITING...</button>
    </div>

    <script>
        // DOM Elements
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('container');
        const scopeToggle = document.getElementById('scopeToggle');
        const fireBtn = document.getElementById('fireBtn');
        const scopeOverlay = document.getElementById('scopeOverlay');
        const scopeCrosshair = document.getElementById('scopeCrosshair');
        const killCountEl = document.getElementById('killCount');
        const ammoDisplay = document.getElementById('ammoDisplay');

        // State
        let objectModel = null;
        let poseModel = null;
        let isDetecting = false;
        let isSniperMode = false;
        let killCount = 0;
        
        // Tracking System
        let trackedTargets = []; // 仅追踪人类
        let nextTargetId = 1;

        // Audio Context
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // --- 音效系统 ---
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gainNode.gain.setValueAtTime(1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'empty') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(2000, now);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        }

        // --- 系统初始化 ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        async function initAI() {
            const loadDetail = document.getElementById('loadDetail');
            const progressBar = document.getElementById('progressBar');
            const startBtn = document.getElementById('startBtn');

            await tf.ready();
            progressBar.style.width = "40%";
            
            // 加载 COCO-SSD (物体识别)
            objectModel = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            progressBar.style.width = "70%";
            
            // 加载 MoveNet (骨骼)
            const detectorConfig = { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING };
            poseModel = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, detectorConfig);
            progressBar.style.width = "100%";

            loadDetail.innerText = "ALL SYSTEMS READY";
            startBtn.disabled = false;
            startBtn.innerText = "ENGAGE SYSTEM";
            startBtn.style.opacity = "1";
            startBtn.classList.add("bg-green-900/50", "text-white", "hover:bg-green-700");
            startBtn.onclick = startSystem;
        }

        async function startSystem() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                // 关键修复：确保视频加载元数据后显示
                video.onloadedmetadata = () => {
                    document.getElementById('loadingOverlay').style.display = 'none';
                    video.style.display = 'block'; // 修复黑屏的关键
                    video.play();
                    isDetecting = true;
                    loop();
                };
            } catch (err) {
                console.error(err);
                alert("Camera access denied or error: " + err.message);
            }
        }

        // --- 交互逻辑 ---
        scopeToggle.onclick = () => {
            isSniperMode = !isSniperMode;
            playSound('empty');
            
            if (isSniperMode) {
                scopeToggle.classList.add('active');
                video.classList.add('zoomed');
                scopeOverlay.style.display = 'block';
                scopeCrosshair.style.display = 'flex';
                ammoDisplay.innerText = "SNIPER MODE: ACTIVE";
                ammoDisplay.classList.add("text-red-500");
                ammoDisplay.classList.remove("text-yellow-400");
            } else {
                scopeToggle.classList.remove('active');
                video.classList.remove('zoomed');
                scopeOverlay.style.display = 'none';
                scopeCrosshair.style.display = 'none';
                ammoDisplay.innerText = "MODE: HYBRID RECON";
                ammoDisplay.classList.remove("text-red-500");
                ammoDisplay.classList.add("text-yellow-400");
            }
        };

        fireBtn.onclick = () => {
            if (!isDetecting) return;
            playSound('shoot');
            container.classList.add('hit-effect');
            setTimeout(() => container.classList.remove('hit-effect'), 200);
            checkHit();
        };

        function checkHit() {
            // 判定屏幕中心
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            let hitRegistered = false;

            trackedTargets.forEach(target => {
                if (target.hp <= 0) return;
                const { x, y, w, h } = target.renderCoords;
                
                // 宽松判定：只要中心点在框内，或者十字准星(中心区域)与框相交
                if (centerX >= x && centerX <= x + w && centerY >= y && centerY <= y + h) {
                    target.hp = 0;
                    hitRegistered = true;
                    target.hitTime = Date.now();
                    killCount++;
                    killCountEl.innerText = killCount.toString().padStart(2, '0');
                    playSound('hit');
                }
            });
            
            if (hitRegistered) {
                ammoDisplay.innerText = "TARGET ELIMINATED";
                setTimeout(() => {
                    ammoDisplay.innerText = isSniperMode ? "SNIPER MODE: ACTIVE" : "MODE: HYBRID RECON";
                }, 1000);
            }
        }

        // --- 核心逻辑 ---

        // 分离预测结果：人 vs 物品
        function processPredictions(predictions, scale, offsetX, offsetY) {
            const now = Date.now();
            
            // 1. 处理人类 (用于追踪和游戏逻辑)
            const personDetections = predictions
                .filter(p => p.class === 'person')
                .map(p => {
                    const [bx, by, bw, bh] = p.bbox; 
                    return { x: bx, y: by, w: bw, h: bh };
                });
            
            // 更新追踪器
            personDetections.forEach(det => {
                let bestDist = 10000;
                let bestTarget = null;
                for (let t of trackedTargets) {
                    const dist = Math.hypot(t.x - det.x, t.y - det.y);
                    if (dist < 150 && dist < bestDist) { // 稍微放宽距离阈值
                        bestDist = dist;
                        bestTarget = t;
                    }
                }
                if (bestTarget) {
                    bestTarget.x = det.x; bestTarget.y = det.y;
                    bestTarget.w = det.w; bestTarget.h = det.h;
                    bestTarget.lastSeen = now;
                } else {
                    trackedTargets.push({
                        id: nextTargetId++,
                        x: det.x, y: det.y, w: det.w, h: det.h,
                        hp: 100, lastSeen: now, hitTime: 0
                    });
                }
            });
            trackedTargets = trackedTargets.filter(t => now - t.lastSeen < 1000);

            // 2. 返回非人类物品 (直接用于绘制)
            const items = predictions
                .filter(p => p.class !== 'person')
                .map(p => {
                    const [bx, by, bw, bh] = p.bbox;
                    return {
                        class: p.class,
                        score: p.score,
                        x: bx, y: by, w: bw, h: bh
                    };
                });

            return items;
        }

        async function loop() {
            if (!isDetecting) return;

            // 1. 清空 Canvas (因为视频在 CSS 层显示了，我们只画 UI)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const videoW = video.videoWidth;
            const videoH = video.videoHeight;
            const screenW = canvas.width;
            const screenH = canvas.height;

            if (videoW === 0) {
                requestAnimationFrame(loop);
                return;
            }

            // 2. 计算 Canvas 与 CSS Video 的对齐
            // Video 使用 object-fit: cover
            const baseScale = Math.max(screenW / videoW, screenH / videoH);
            const sniperZoom = isSniperMode ? 2.5 : 1.0;
            const finalScale = baseScale * sniperZoom;

            // 居中偏移量
            const drawW = videoW * finalScale;
            const drawH = videoH * finalScale;
            const offsetX = (screenW - drawW) / 2;
            const offsetY = (screenH - drawH) / 2;

            if (video.readyState === 4) {
                // 3. 运行模型 (提高置信度到 0.25 使得更多物品被识别)
                const predictions = await objectModel.detect(video, 30, 0.25);
                
                // 4. 处理数据
                const items = processPredictions(predictions, finalScale, offsetX, offsetY);

                // 5. 绘制非人类物品 (青色)
                drawItems(items, finalScale, offsetX, offsetY);

                // 6. 绘制人类目标 (绿色/红色)
                drawTargets(finalScale, offsetX, offsetY);

                // 7. 绘制骨骼 (仅在非狙击模式下，为了清晰)
                if (!isSniperMode) {
                    const poses = await poseModel.estimatePoses(video);
                    drawSkeletons(poses, finalScale, offsetX, offsetY);
                }
            }
            
            requestAnimationFrame(loop);
        }

        function drawItems(items, scale, offsetX, offsetY) {
            ctx.lineWidth = 2;
            ctx.font = '14px "Courier New"';

            items.forEach(item => {
                const x = item.x * scale + offsetX;
                const y = item.y * scale + offsetY;
                const w = item.w * scale;
                const h = item.h * scale;

                // 物品绘制样式：青色，科技感
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.strokeRect(x, y, w, h);

                // 标签背景
                const label = `${item.class.toUpperCase()} ${Math.round(item.score * 100)}%`;
                const textWidth = ctx.measureText(label).width;
                
                ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.fillRect(x, y - 20, textWidth + 10, 20);
                
                ctx.fillStyle = '#000';
                ctx.fillText(label, x + 5, y - 5);
            });
        }

        function drawTargets(scale, offsetX, offsetY) {
            trackedTargets.forEach(target => {
                const rx = target.x * scale + offsetX;
                const ry = target.y * scale + offsetY;
                const rw = target.w * scale;
                const rh = target.h * scale;
                
                // 保存渲染坐标用于击杀判定
                target.renderCoords = { x: rx, y: ry, w: rw, h: rh };

                const isDead = target.hp <= 0;
                const color = isDead ? '#ff0000' : '#00ff00';

                ctx.strokeStyle = color;
                ctx.lineWidth = isSniperMode ? 3 : 2;

                if (isDead) {
                    // 死亡十字
                    ctx.beginPath();
                    ctx.moveTo(rx, ry); ctx.lineTo(rx + rw, ry + rh);
                    ctx.moveTo(rx + rw, ry); ctx.lineTo(rx, ry + rh);
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText("ELIMINATED", rx, ry - 5);
                } else {
                    // 存活框
                    // 只有在狙击模式或者靠近中心时才画完整的框，否则画角标（优化视觉）
                    if (isSniperMode) {
                        // 狙击模式：括号式瞄准框
                        const len = rw / 4;
                        ctx.beginPath();
                        // 左上
                        ctx.moveTo(rx, ry + len); ctx.lineTo(rx, ry); ctx.lineTo(rx + len, ry);
                        // 右上
                        ctx.moveTo(rx + rw - len, ry); ctx.lineTo(rx + rw, ry); ctx.lineTo(rx + rw, ry + len);
                        // 右下
                        ctx.moveTo(rx + rw, ry + rh - len); ctx.lineTo(rx + rw, ry + rh); ctx.lineTo(rx + rw - len, ry + rh);
                        // 左下
                        ctx.moveTo(rx + len, ry + rh); ctx.lineTo(rx, ry + rh); ctx.lineTo(rx, ry + rh - len);
                        ctx.stroke();
                    } else {
                         ctx.strokeRect(rx, ry, rw, rh);
                    }

                    // 血条
                    ctx.fillStyle = '#333';
                    ctx.fillRect(rx, ry - 10, rw, 6);
                    ctx.fillStyle = color;
                    ctx.fillRect(rx, ry - 10, rw * (target.hp / 100), 6);

                    // 距离/信息
                    ctx.fillStyle = color;
                    ctx.font = '12px Courier New';
                    // 模拟距离: 假设人高1.7m, 根据框高估算
                    const dist = Math.max(5, Math.round(5000 / rh)); 
                    ctx.fillText(`TARGET ${dist}m`, rx, ry + rh + 15);
                }
            });
        }

        function drawSkeletons(poses, scale, offsetX, offsetY) {
            if (!poses) return;
            const connections = [[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[7,9],[6,8],[8,10],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]];
            
            poses.forEach(pose => {
                // 简单过滤：检查这个骨骼是否属于一个“已死亡”的目标
                // (此处为简化计算，暂不进行严格匹配，仅根据框的位置粗略判断，或者直接全部绘制)
                
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                
                // 绘制连线
                connections.forEach(([i, j]) => {
                    const kp1 = pose.keypoints[i];
                    const kp2 = pose.keypoints[j];
                    if (kp1.score > 0.3 && kp2.score > 0.3) {
                        const x1 = kp1.x * scale + offsetX;
                        const y1 = kp1.y * scale + offsetY;
                        const x2 = kp2.x * scale + offsetX;
                        const y2 = kp2.y * scale + offsetY;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
            });
        }

        initAI();

    </script>
</body>
</html>